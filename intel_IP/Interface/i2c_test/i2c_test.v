
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module i2c_test(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// EEPROM //////////
	I2C_SCLK,
	I2C_SDAT,
	
	
	
	//////////// TEST //////////
	COUNT,
	SD_COUNTER
	
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// EEPROM //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// TEST //////////
output	[5:0]	 SD_COUNTER;
output	[9:0]	 COUNT;

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire       	 	reset_n;													//reset signal


reg				GO; 														//flag to start our i2c write operation
reg 				[6:0]SD_COUNTER; 										//counter to keep track of our i2c
reg				SDI; 														//register value for SDAT - slave device input
reg 				SCLK; 													//register value for SCLK
reg	[9:0]		COUNT; 													//clock

//=============================================================================
// Structural coding
//=============================================================================
assign   reset_n = KEY[0];

/////////////////////////////////////////////////////////////////////

always@(posedge CLOCK_50) COUNT <= COUNT + 1;

always @ (posedge COUNT[9] or negedge reset_n)
begin
	if (!reset_n)
		GO <= 0;
	else
		if(!KEY[1])
		GO <= 1;
end

//I2C COUNTER
always @(posedge COUNT[9] or negedge reset_n) 
begin
	if (!reset_n) 
		SD_COUNTER <= 6'b0;
	else 
	begin
		if (!GO) 
			SD_COUNTER <= 0;
		else 
			if (SD_COUNTER < 33) 
				SD_COUNTER <= SD_COUNTER+1;	
	end
end

//I2C Operation
always @(posedge COUNT[9] or negedge reset_n) 
begin
	if (!reset_n) 
	begin 
		SCLK <= 1;
		SDI <= 1; 
	end
	else
	case (SD_COUNTER)
		
		6'd0  : begin SDI<=1; SCLK<=1;end
		
		//start
		6'd1  : SDI <= 0;
		6'd2  : SCLK <= 0;
		
		//SLAVE ADDR
		6'd3  : SDI <= 1;
		6'd4  : SDI <= 1;
		6'd5  : SDI <= 1;
		6'd6  : SDI <= 0;
		6'd7  : SDI <= 0;
		6'd8  : SDI <= 0;
		6'd9  : SDI <= 0;
		6'd10 : SDI <= 0;	
		6'd11 : SDI <= 1'bz;//Slave ACK
	
		//SUB ADDR
		6'd12  : SDI <= 0;
		6'd13  : SDI <= 0;
		6'd14  : SDI <= 0;
		6'd15  : SDI <= 0;
		6'd16  : SDI <= 0;
		6'd17  : SDI <= 0;
		6'd18  : SDI <= 0;
		6'd19  : SDI <= 0;
		6'd20  : SDI <= 1'bz;//Slave ACK
	
		//DATA
		6'd21  : SDI <= 1; 
		6'd22  : SDI <= 0;
		6'd23  : SDI <= 1;
		6'd24  : SDI <= 0;
		6'd25  : SDI <= 1;
		6'd26  : SDI <= 0;
		6'd27  : SDI <= 1;
		6'd28  : SDI <= 0;
		6'd29  : SDI <= 1'b1;//Slave ACK
		
		//stop
		6'd30 : begin SDI <= 1'b0; SCLK <= 1'b1; end	
		6'd31 : SDI <= 1'b1;  
	endcase
end

assign I2C_SCLK =	((SD_COUNTER >= 4) & (SD_COUNTER <= 31))? ~COUNT[9] : SCLK;
assign I2C_SDAT = SDI;

endmodule
